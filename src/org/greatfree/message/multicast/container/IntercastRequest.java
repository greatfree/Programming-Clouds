package org.greatfree.message.multicast.container;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import org.greatfree.message.ServerMessage;
import org.greatfree.message.multicast.MulticastMessageType;
import org.greatfree.util.IPAddress;
import org.greatfree.util.UtilConfig;

// Created: 01/26/2019, Bing Li
// public abstract class IntercastRequest extends Notification
// public abstract class IntercastRequest extends Request
public abstract class IntercastRequest extends ServerMessage
{
	private static final long serialVersionUID = -8648346803761360362L;
	
	private int applicationID;

	private int intercastType;
	private String sourceKey;
	private String destinationKey;
	private Set<String> destinationKeys;
	// Now I need to implement the root based intercasting. So the IP address is not necessary to send to the child. I will implement the children-based intercasing later. 02/15/2019, Bing Li 
//	private IPAddress destinationIP;

	// According to the value, a child is able to identify whether it needs to forward the notification to the destination child or it itself is the destination child and it needs to process the message. 02/09/2019, Bing Li
//	private boolean isForwarded;
	
	private IPAddress destinationIP;
	private Set<IPAddress> destinationIPs;
	
	// The reason to place a map here is due to the fact that it is possible that one child has multiple application-level destination keys resided. 03/14/2019, Bing Li
	// Different from destination keys, which are generated by the application-level ID, the children keys are generated by the IP addresses of children in the clusters. 02/28/2019, Bing Li
	private Map<String, Set<String>> childDestionations;

	public IntercastRequest(String srcKey, String dstKey, int applicationID)
	{
//		super(srcKey, MulticastMessageType.INTERCAST_REQUEST, applicationID);
		super(MulticastMessageType.INTERCAST_REQUEST);
		this.applicationID = applicationID;
//		super(dstKey, MulticastMessageType.INTERCAST_REQUEST, applicationID);
		this.intercastType = MulticastMessageType.INTER_UNICAST_REQUEST;
		this.sourceKey = srcKey;
		this.destinationKey = dstKey;
		this.destinationKeys = null;
//		this.isForwarded = false;

		this.childDestionations = new HashMap<String, Set<String>>();
	}
	
	public IntercastRequest(int intercastType, String srcKey, Set<String> dstKeys, int applicationID)
	{
//		super(srcKey, MulticastMessageType.INTERCAST_REQUEST, applicationID);
		super(MulticastMessageType.INTERCAST_REQUEST);
		this.applicationID = applicationID;
		this.intercastType = intercastType;
		this.sourceKey = srcKey;
		this.destinationKey = UtilConfig.EMPTY_STRING;
		this.destinationKeys = dstKeys;

		this.childDestionations = new HashMap<String, Set<String>>();
	}
	
	/*
	 * The constructor is a new one. It is used when the destinationKey/destinationKeys cannot be determined at the client side. For example, it is possible that the number of destinations is large. The client might not be suitable to save the keys. The destination information has to be assigned at the source child of the intercast. 07/22/2019, Bing Li
	 * 
	 * One example is like this. In the group chatting case, a client has to retrieve all of the members in the group before a group chatting message is broadcast. But it is not necessary if the constructor is employed. In the group chatting, usually, the number of group members (destination keys) is small. So it is fine. But in the case of Twitter, the large might be large. It is not proper to retrieve the large amount of data from the cluster and keep it on the client. The constructor is useful. 07/22/2019, Bing Li
	 * 
	 */
	public IntercastRequest(int intercastType, String srcKey, int applicationID)
	{
		super(MulticastMessageType.INTERCAST_REQUEST);
		this.applicationID = applicationID;
		this.intercastType = intercastType;
		this.sourceKey = srcKey;
		this.destinationKey = UtilConfig.EMPTY_STRING;
		this.destinationKeys = null;
		this.childDestionations = new HashMap<String, Set<String>>();
	}
	
	public int getApplicationID()
	{
		return this.applicationID;
	}
	
	public int getIntercastType()
	{
		return this.intercastType;
	}

	public String getSourceKey()
	{
		return this.sourceKey;
	}
	
	/*
	 * When the constructor which has no destination is used, the method might be called at the source child to set a destination. 07/22/2019, Bing Li
	 */
	public void setDestinationKey(String dstKey)
	{
		this.destinationKey = dstKey;
	}
	
	public String getDestinationKey()
	{
		return this.destinationKey;
	}
	
	/*
	 * When the constructor which has no destinations is used, the method might be called at the source child to set a destination. 07/22/2019, Bing Li
	 */
	public void setDestinationKeys(Set<String> dstKeys)
	{
		this.destinationKeys = dstKeys;
	}
	
	public Set<String> getDestinationKeys()
	{
		return this.destinationKeys;
	}

	public void setDestinationIP(IPAddress ip)
	{
		this.destinationIP = ip;
	}
	
	public IPAddress getDestinationIP()
	{
		return this.destinationIP;
	}
	
	public void setChildDestination(Map<String, Set<String>> cds)
	{
		this.childDestionations = cds;
	}
	
	public Map<String, Set<String>> getChildDestinations()
	{
		return this.childDestionations;
	}
	
	public void setDestinationIPs(Set<IPAddress> ips)
	{
		this.destinationIPs = ips;
	}
	
	public Set<IPAddress> getDestinationIPs()
	{
		return this.destinationIPs;
	}

	/*
	public void setForwarded()
	{
		this.isForwarded = true;
	}
	
	public boolean isForwarded()
	{
		return this.isForwarded;
	}
	*/
}
